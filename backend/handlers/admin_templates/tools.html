{{template "base" .}}

{{define "title"}}Tools - strmr Admin{{end}}

{{define "content"}}
<div class="page-header">
    <h1>Tools</h1>
    <p>Import and manage your media library</p>
</div>

<!-- INTEGRATIONS CATEGORY -->
<div class="settings-group">
    <div class="group-title">Integrations</div>

    <!-- Trakt Accounts Section -->
    <div class="section" id="traktAccountSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 12l2 2 4-4"/>
                </svg>
                Trakt Accounts
            </div>
            <span id="traktStatusBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Register Trakt accounts and link them to profiles. Each profile can have its own Trakt account for scrobbling.
                Create an app at <a href="https://trakt.tv/oauth/applications" target="_blank">trakt.tv/oauth/applications</a> to get Client ID and Secret.
            </p>

            <!-- Trakt Accounts List -->
            <div id="traktAccountsList" style="margin-bottom: 1.5rem;">
                <!-- Accounts will be rendered here -->
            </div>

            <!-- Add New Account Button -->
            <button class="btn btn-primary" onclick="showAddTraktAccountForm()" id="addTraktAccountBtn">
                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 0.5rem;">
                    <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                Add Trakt Account
            </button>

            <!-- Add Account Form (hidden by default) -->
            <div id="traktAddAccountForm" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border);">
                <h4 style="margin-bottom: 1rem;">Add New Trakt Account</h4>
                <div class="form-group">
                    <label class="form-label">Account Name</label>
                    <input type="text" class="form-input" id="newTraktAccountName" placeholder="e.g., Family Account">
                </div>
                <div class="form-group">
                    <label class="form-label">Client ID</label>
                    <input type="text" class="form-input" id="newTraktClientId" placeholder="From trakt.tv/oauth/applications">
                </div>
                <div class="form-group">
                    <label class="form-label">Client Secret</label>
                    <input type="password" class="form-input" id="newTraktClientSecret" placeholder="From trakt.tv/oauth/applications">
                </div>
                <div class="btn-group" style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="hideAddTraktAccountForm()">Cancel</button>
                    <button class="btn btn-primary" onclick="createTraktAccount()">Create Account</button>
                </div>
            </div>

            <!-- OAuth Waiting Modal -->
            <div id="traktAuthModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1000; justify-content: center; align-items: center;">
                <div style="background: var(--bg-elevated); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div class="spinner" style="margin: 0 auto 1rem;"></div>
                    <h3 style="margin-bottom: 0.5rem;">Waiting for authorization...</h3>
                    <p class="text-muted" style="margin-bottom: 1rem;">
                        Go to <a id="traktAuthUrl" href="#" target="_blank" style="color: var(--accent);">trakt.tv/activate</a> and enter code:
                    </p>
                    <div id="traktUserCode" style="font-family: monospace; font-size: 2rem; font-weight: bold; color: var(--accent); margin-bottom: 1.5rem;"></div>
                    <button class="btn btn-secondary" onclick="cancelTraktAuth()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile-Trakt Linking Section -->
    <div class="section" id="profileTraktLinkingSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="8.5" cy="7" r="4"/>
                    <line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/>
                </svg>
                Profile Trakt Linking
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Link each profile to a Trakt account. When a profile watches content, it will sync to their linked Trakt account.
                <br><strong style="color: var(--text-secondary);">Note:</strong> Syncing only occurs if the linked Trakt account has scrobbling enabled (toggle above).
            </p>
            <div id="profileTraktLinkingList">
                <!-- Profile linking rows will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Plex Account Section -->
    <div class="section" id="plexAccountSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
                Plex Account
            </div>
            <span id="plexStatusBadge" class="status-badge"></span>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <p class="text-muted" style="margin-bottom: 1rem;">
                Connect your Plex account to import your watchlist.
            </p>

            <!-- Not Connected State -->
            <div id="plexNotConnected">
                <button class="btn btn-primary" onclick="loginWithPlex()" id="plexLoginBtn">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
                        <polyline points="10 17 15 12 10 7"/>
                        <line x1="15" y1="12" x2="3" y2="12"/>
                    </svg>
                    Login with Plex
                </button>
            </div>

            <!-- Waiting for auth -->
            <div id="plexAuthWaiting" style="display: none;">
                <div class="status-box">
                    <div class="spinner"></div>
                    <div>
                        <div class="status-title">Waiting for authorization...</div>
                        <div class="text-muted">Complete the login in the Plex window</div>
                    </div>
                </div>
                <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="cancelPlexAuth()">Cancel</button>
            </div>

            <!-- Connected State -->
            <div id="plexConnectedSection" style="display: none;">
                <div class="connected-status">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                        <polyline points="22 4 12 14.01 9 11.01"/>
                    </svg>
                    <div>
                        <div class="status-title" style="color: var(--success);">Connected to Plex</div>
                        <div class="text-muted" id="plexConnectedUsername"></div>
                    </div>
                    <button class="btn btn-secondary btn-sm" onclick="disconnectPlex()">Disconnect</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- IMPORT CATEGORY -->
<div class="settings-group">
    <div class="group-title">Import</div>

    <!-- Watchlist Section -->
    <div class="section open" id="watchlistSection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                </svg>
                Watchlist
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <!-- Plex Watchlist Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Plex Watchlist</h3>
                </div>
                <div class="import-card-body" id="plexWatchlistCard">
                    <!-- Not Connected -->
                    <div id="plexWatchlistNotConnected">
                        <p class="text-muted">Connect your Plex account in the Integrations section above to import your watchlist.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="plexWatchlistConnected" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="plexProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="plexFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchPlexWatchlist()" id="plexFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load Watchlist from Plex
                            </button>
                        </div>
                        <div id="plexImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importPlexWatchlist()" id="plexImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="plexSelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetPlexWatchlistLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="plexLoadingSection" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span>Loading watchlist...</span>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="plexPreviewSection" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="plexWatchlistCount">0 items</span>
                                <span class="text-muted"> in your Plex watchlist</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="plexSelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="plexSelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="plexSelectAllCheckbox" onchange="plexSelectAll(this.checked)" checked></th>
                                        <th style="width: 50px;"></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 100px;">IDs</th>
                                    </tr>
                                </thead>
                                <tbody id="plexWatchlistTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="plexImportingSection" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="plexImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="plexCompleteSection" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="plexImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetPlexImport()">Import More</button>
                    </div>
                </div>
            </div>

            <!-- Trakt Watchlist Import (TODO) -->
            <div class="import-card todo-card">
                <div class="import-card-header">
                    <h3>Trakt Watchlist</h3>
                    <span class="todo-badge">Coming Soon</span>
                </div>
                <div class="import-card-body">
                    <p class="text-muted">Import your Trakt watchlist. Connect your Trakt account in the Integrations section below first.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Watch History Section -->
    <div class="section" id="historySection">
        <div class="section-header" onclick="toggleSection(this)">
            <div class="section-title">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
                Watch History
            </div>
            <svg class="section-toggle" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        </div>
        <div class="section-content">
            <!-- Plex Watch History (TODO) -->
            <div class="import-card todo-card">
                <div class="import-card-header">
                    <h3>Plex Watch History</h3>
                    <span class="todo-badge">Coming Soon</span>
                </div>
                <div class="import-card-body">
                    <p class="text-muted">Import your Plex watch history to strmr.</p>
                </div>
            </div>

            <!-- Trakt Watch History Import -->
            <div class="import-card">
                <div class="import-card-header">
                    <h3>Trakt Watch History</h3>
                </div>
                <div class="import-card-body" id="traktHistoryCard">
                    <!-- Not Connected -->
                    <div id="traktHistoryNotConnected">
                        <p class="text-muted">Connect your Trakt account in the Integrations section above to import your watch history.</p>
                    </div>

                    <!-- Connected - Ready to import -->
                    <div id="traktHistoryConnected" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Import from Trakt Account</label>
                            <select id="traktHistoryAccountSelect" class="form-select" style="max-width: 300px;">
                                <!-- Populated by JavaScript -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Import to Profile</label>
                            <select id="traktHistoryProfileSelect" class="form-select" style="max-width: 300px;">
                                {{range .Users}}
                                <option value="{{.ID}}">{{.Name}}</option>
                                {{end}}
                            </select>
                        </div>

                        <!-- Action buttons - swap between Load and Import -->
                        <div id="traktHistoryFetchBtnWrapper">
                            <button class="btn btn-primary" onclick="fetchTraktHistory()" id="traktHistoryFetchBtn">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="1 4 1 10 7 10"/>
                                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                </svg>
                                Load History from Trakt
                            </button>
                        </div>
                        <div id="traktHistoryImportBtnWrapper" style="display: none;">
                            <div class="import-action-bar">
                                <button class="btn btn-primary" onclick="importTraktHistory()" id="traktHistoryImportBtn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                        <polyline points="17 8 12 3 7 8"/>
                                        <line x1="12" y1="3" x2="12" y2="15"/>
                                    </svg>
                                    Import <span id="traktHistorySelectedCount">0</span> Selected
                                </button>
                                <button class="btn btn-secondary" onclick="resetTraktHistoryLoad()">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="1 4 1 10 7 10"/>
                                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                                    </svg>
                                    Reload
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Loading -->
                    <div id="traktHistoryLoading" style="display: none;">
                        <div class="loading-box">
                            <div class="spinner"></div>
                            <span>Loading watch history...</span>
                        </div>
                    </div>

                    <!-- Preview Table -->
                    <div id="traktHistoryPreview" style="display: none; margin-top: 1rem;">
                        <div class="preview-header">
                            <div>
                                <span class="preview-count" id="traktHistoryCount">0 items</span>
                                <span class="text-muted"> in your Trakt history</span>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-secondary btn-sm" onclick="traktHistorySelectAll(true)">Select All</button>
                                <button class="btn btn-secondary btn-sm" onclick="traktHistorySelectAll(false)">Deselect All</button>
                            </div>
                        </div>

                        <div class="table-container">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"><input type="checkbox" id="traktHistorySelectAllCheckbox" onchange="traktHistorySelectAll(this.checked)" checked></th>
                                        <th>Title</th>
                                        <th style="width: 80px;">Year</th>
                                        <th style="width: 100px;">Type</th>
                                        <th style="width: 150px;">Watched</th>
                                    </tr>
                                </thead>
                                <tbody id="traktHistoryTableBody"></tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Import Progress -->
                    <div id="traktHistoryImporting" style="display: none; margin-top: 1rem;">
                        <div class="status-box">
                            <div class="spinner"></div>
                            <div>
                                <div class="status-title">Importing items...</div>
                                <div class="text-muted" id="traktHistoryImportProgress">0 of 0</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Complete -->
                    <div id="traktHistoryComplete" style="display: none; margin-top: 1rem;">
                        <div class="success-box">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="var(--success)" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                            <div>
                                <div class="status-title" style="color: var(--success);">Import Complete</div>
                                <div id="traktHistoryImportSummary" class="text-muted"></div>
                            </div>
                        </div>
                        <button class="btn btn-secondary" style="margin-top: 1rem;" onclick="resetTraktHistoryImport()">Import More</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    /* Link styling - consistent light grey with underline */
    a {
        color: #9ca3af;
        text-decoration: underline;
    }
    a:visited {
        color: #9ca3af;
    }
    a:hover {
        color: #d1d5db;
    }
    .settings-group {
        margin-bottom: 2rem;
    }
    .group-title {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin-bottom: 0.75rem;
        padding-left: 0.25rem;
    }
    .section {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: 0.5rem;
        overflow: hidden;
    }
    .section-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem 1.25rem;
        cursor: pointer;
        transition: background 0.15s;
    }
    .section-header:hover {
        background: var(--bg-hover);
    }
    .section-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 500;
        flex: 1;
    }
    .section-toggle {
        transition: transform 0.2s;
    }
    .section.open .section-toggle {
        transform: rotate(180deg);
    }
    .section-content {
        display: none;
        padding: 0 1.25rem 1.25rem;
    }
    .section.open .section-content {
        display: block;
    }
    .import-card {
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: 1rem;
        overflow: hidden;
    }
    .import-card:last-child {
        margin-bottom: 0;
    }
    .import-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border);
        background: var(--bg-secondary);
    }
    .import-card-header h3 {
        margin: 0;
        font-size: 0.9375rem;
        font-weight: 500;
    }
    .import-card-body {
        padding: 1rem;
    }
    .todo-card {
        opacity: 0.7;
    }
    .todo-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        background: var(--warning);
        color: var(--bg-primary);
        border-radius: 4px;
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
    }
    .status-badge {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
    }
    .status-badge.connected {
        background: rgba(34, 197, 94, 0.15);
        color: var(--success);
    }
    .status-badge.disconnected {
        background: var(--bg-tertiary);
        color: var(--text-muted);
    }
    /* Toggle switch styling */
    .toggle-option {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .toggle-label {
        flex: 1;
    }
    .toggle-title {
        font-weight: 500;
        margin-bottom: 0.25rem;
    }
    .toggle-description {
        font-size: 0.875rem;
    }
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--bg-tertiary);
        transition: 0.3s;
        border-radius: 24px;
    }
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
    }
    .toggle-switch input:checked + .toggle-slider {
        background-color: var(--accent);
    }
    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }
    .toggle-switch input:disabled + .toggle-slider {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .status-box {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: var(--radius);
    }
    .status-title {
        font-weight: 500;
    }
    .loading-box {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        padding: 2rem;
        color: var(--text-muted);
    }
    .success-box {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid var(--success);
        border-radius: var(--radius);
    }
    .connected-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem;
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid var(--success);
        border-radius: var(--radius);
    }
    .connected-status .btn {
        margin-left: auto;
    }
    .preview-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 0.75rem;
    }
    .preview-count {
        font-weight: 500;
    }
    .table-container {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: var(--radius);
    }
    .data-table {
        width: 100%;
        border-collapse: collapse;
    }
    .data-table th,
    .data-table td {
        padding: 0.75rem 1rem;
        text-align: left;
        border-bottom: 1px solid var(--border);
    }
    .data-table th {
        background: var(--bg-secondary);
        font-weight: 500;
        font-size: 0.875rem;
        color: var(--text-secondary);
    }
    .data-table tbody tr:hover {
        background: var(--bg-hover);
    }
    .data-table tbody tr.disabled {
        opacity: 0.5;
    }
    .import-actions {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    .import-action-bar {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 1rem;
    }
    .poster-thumb {
        width: 35px;
        height: 52px;
        object-fit: cover;
        border-radius: 4px;
        background: var(--bg-tertiary);
    }
    .type-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
    }
    .type-badge.movie {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent);
    }
    .type-badge.series {
        background: rgba(34, 197, 94, 0.2);
        color: var(--success);
    }
    .type-badge.episode {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
    }
    .id-badges {
        display: flex;
        gap: 0.25rem;
        flex-wrap: wrap;
    }
    .id-badge {
        font-size: 0.7rem;
        padding: 0.125rem 0.375rem;
        background: var(--bg-secondary);
        border-radius: 3px;
        color: var(--text-muted);
    }
    input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }
    .text-muted {
        color: var(--text-muted);
    }
    .form-group {
        margin-bottom: 1rem;
    }
    .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
    }
    .form-input {
        width: 100%;
        max-width: 400px;
        padding: 0.5rem 0.75rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        color: var(--text-primary);
        font-size: 0.875rem;
    }
    .form-input:focus {
        outline: none;
        border-color: var(--accent);
    }
    .btn-group {
        display: flex;
        gap: 0.5rem;
    }
</style>
{{end}}

{{define "scripts"}}
<script>
    // ========== Section Toggle ==========
    function toggleSection(header) {
        const section = header.parentElement;
        section.classList.toggle('open');
    }

    // ========== Plex State ==========
    let plexToken = null;
    let plexWatchlistItems = [];
    let plexSelectedItems = new Set();
    let plexPollInterval = null;

    // ========== Trakt State ==========
    let traktAccounts = [];
    let traktHistoryItems = [];
    let traktHistorySelectedItems = new Set();
    let traktAuthAccountId = null;
    let traktPollInterval = null;
    let userProfiles = [];

    // ========== Initialize ==========
    document.addEventListener('DOMContentLoaded', function() {
        // Load Plex and Trakt status from backend
        loadPlexStatus();
        loadTraktAccounts();
        loadUserProfiles();
    });

    // ========== Plex Account Functions ==========
    let plexStatus = { connected: false, username: '' };

    async function loadPlexStatus() {
        try {
            const response = await fetch('/admin/api/plex/status');
            const data = await response.json();
            plexStatus = data;
            updatePlexUI();
        } catch (err) {
            console.error('Failed to load Plex status:', err);
        }
    }

    function updatePlexUI() {
        const badge = document.getElementById('plexStatusBadge');
        const notConnected = document.getElementById('plexNotConnected');
        const connectedSection = document.getElementById('plexConnectedSection');
        const watchlistNotConnected = document.getElementById('plexWatchlistNotConnected');
        const watchlistConnected = document.getElementById('plexWatchlistConnected');

        if (plexStatus.connected) {
            badge.textContent = 'Connected';
            badge.className = 'status-badge connected';
            notConnected.style.display = 'none';
            connectedSection.style.display = 'block';
            document.getElementById('plexConnectedUsername').textContent = 'Logged in as ' + plexStatus.username;

            // Update watchlist import section
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'none';
            if (watchlistConnected) watchlistConnected.style.display = 'block';
        } else {
            badge.textContent = 'Not Connected';
            badge.className = 'status-badge disconnected';
            notConnected.style.display = 'block';
            connectedSection.style.display = 'none';

            // Update watchlist import section
            if (watchlistNotConnected) watchlistNotConnected.style.display = 'block';
            if (watchlistConnected) watchlistConnected.style.display = 'none';
        }
    }

    async function disconnectPlex() {
        try {
            const response = await fetch('/admin/api/plex/disconnect', { method: 'POST' });
            if (response.ok) {
                plexStatus = { connected: false, username: '' };
                updatePlexUI();
            }
        } catch (err) {
            console.error('Failed to disconnect Plex:', err);
        }
    }

    function cancelPlexAuth() {
        if (plexPollInterval) {
            clearInterval(plexPollInterval);
            plexPollInterval = null;
        }
        document.getElementById('plexAuthWaiting').style.display = 'none';
        document.getElementById('plexNotConnected').style.display = 'block';
    }

    // ========== User Profiles Functions ==========
    async function loadUserProfiles() {
        try {
            const response = await fetch('/admin/api/profiles');
            if (response.ok) {
                userProfiles = await response.json();
                renderProfileTraktLinking();
            }
        } catch (err) {
            console.error('Failed to load user profiles:', err);
        }
    }

    // ========== Trakt Accounts Functions ==========
    async function loadTraktAccounts() {
        try {
            const response = await fetch('/admin/api/trakt/accounts');
            const data = await response.json();
            traktAccounts = data.accounts || [];
            renderTraktAccountsList();
            updateTraktStatusBadge();
            updateTraktHistorySection();
        } catch (err) {
            console.error('Failed to load Trakt accounts:', err);
        }
    }

    function updateTraktStatusBadge() {
        const badge = document.getElementById('traktStatusBadge');
        const connectedCount = traktAccounts.filter(a => a.connected).length;
        if (connectedCount > 0) {
            badge.textContent = `${connectedCount} Connected`;
            badge.className = 'status-badge connected';
        } else if (traktAccounts.length > 0) {
            badge.textContent = 'Not Connected';
            badge.className = 'status-badge disconnected';
        } else {
            badge.textContent = 'No Accounts';
            badge.className = 'status-badge';
        }
    }

    function renderTraktAccountsList() {
        const container = document.getElementById('traktAccountsList');
        if (traktAccounts.length === 0) {
            container.innerHTML = '<p class="text-muted">No Trakt accounts configured. Add one to get started.</p>';
            return;
        }

        container.innerHTML = traktAccounts.map(account => `
            <div class="trakt-account-card" style="padding: 1rem; margin-bottom: 0.75rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border); overflow: hidden;">
                <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: flex-start; gap: 0.75rem;">
                    <div style="flex: 1; min-width: 150px;">
                        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                            <strong style="word-break: break-word;">${escapeHtml(account.name || 'Unnamed Account')}</strong>
                            ${account.connected ?
                                `<span class="status-badge connected" style="font-size: 0.75rem;">Connected</span>` :
                                `<span class="status-badge disconnected" style="font-size: 0.75rem;">Not Connected</span>`
                            }
                        </div>
                        ${account.connected && account.username ?
                            `<div class="text-muted" style="font-size: 0.875rem;">Logged in as ${escapeHtml(account.username)}</div>` :
                            ''
                        }
                        ${account.linkedProfiles && account.linkedProfiles.length > 0 ?
                            `<div class="text-muted" style="font-size: 0.8rem; margin-top: 0.25rem;">
                                Linked to: ${account.linkedProfiles.map(pid => {
                                    const profile = userProfiles.find(p => p.id === pid);
                                    return profile ? escapeHtml(profile.name) : pid;
                                }).join(', ')}
                            </div>` :
                            ''
                        }
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; flex-shrink: 0; align-items: center;">
                        ${account.connected ? `
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-right: 0.5rem;" title="Enable scrobbling to sync watch history to Trakt">
                                <label class="toggle-switch">
                                    <input type="checkbox" ${account.scrobblingEnabled ? 'checked' : ''} onchange="toggleAccountScrobbling('${account.id}', this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span style="font-size: 0.75rem; color: var(--text-muted);">Scrobble</span>
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="disconnectTraktAccount('${account.id}')">Disconnect</button>
                        ` : `
                            <button class="btn btn-primary btn-sm" onclick="connectTraktAccount('${account.id}')">Connect</button>
                        `}
                        <button class="btn btn-secondary btn-sm" onclick="deleteTraktAccount('${account.id}')" style="color: var(--danger);">Delete</button>
                    </div>
                </div>
            </div>
        `).join('');
    }

    function renderProfileTraktLinking() {
        const container = document.getElementById('profileTraktLinkingList');
        if (userProfiles.length === 0) {
            container.innerHTML = '<p class="text-muted">No profiles found.</p>';
            return;
        }

        const connectedAccounts = traktAccounts.filter(a => a.connected);

        container.innerHTML = userProfiles.map(profile => {
            const currentAccountId = profile.traktAccountId || '';
            // Check if current account ID exists in any account (connected or not)
            const currentAccountExists = currentAccountId && traktAccounts.some(a => a.id === currentAccountId);
            const currentAccountConnected = currentAccountId && connectedAccounts.some(a => a.id === currentAccountId);
            // Show warning if profile has an account ID that doesn't exist
            const orphanedLink = currentAccountId && !currentAccountExists;

            return `
                <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; padding: 0.75rem; margin-bottom: 0.5rem; background: var(--bg-surface); border-radius: 8px; border: 1px solid var(--border); gap: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; min-width: 120px;">
                        <div style="width: 36px; height: 36px; border-radius: 50%; background: ${profile.color || 'var(--bg-elevated)'}; display: flex; align-items: center; justify-content: center; font-weight: 600; color: white; flex-shrink: 0;">
                            ${profile.name.charAt(0).toUpperCase()}
                        </div>
                        <span style="font-weight: 500;">${escapeHtml(profile.name)}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        ${orphanedLink ? `<span class="status-badge" style="background: var(--warning); color: #000; font-size: 0.7rem;">Orphaned link</span>` : ''}
                        <select class="form-select" style="max-width: 200px; min-width: 150px;" onchange="updateProfileTraktLink('${profile.id}', this.value)">
                            <option value="" ${!currentAccountId ? 'selected' : ''}>No Trakt Account</option>
                            ${orphanedLink ? `<option value="${currentAccountId}" selected style="color: var(--warning);">âš  Unknown Account</option>` : ''}
                            ${connectedAccounts.map(acc => `
                                <option value="${acc.id}" ${currentAccountId === acc.id ? 'selected' : ''}>
                                    ${escapeHtml(acc.name || acc.username || 'Unnamed')}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                </div>
            `;
        }).join('');
    }

    function showAddTraktAccountForm() {
        document.getElementById('traktAddAccountForm').style.display = 'block';
        document.getElementById('addTraktAccountBtn').style.display = 'none';
    }

    function hideAddTraktAccountForm() {
        document.getElementById('traktAddAccountForm').style.display = 'none';
        document.getElementById('addTraktAccountBtn').style.display = 'inline-flex';
        document.getElementById('newTraktAccountName').value = '';
        document.getElementById('newTraktClientId').value = '';
        document.getElementById('newTraktClientSecret').value = '';
    }

    async function createTraktAccount() {
        const name = document.getElementById('newTraktAccountName').value.trim();
        const clientId = document.getElementById('newTraktClientId').value.trim();
        const clientSecret = document.getElementById('newTraktClientSecret').value.trim();

        if (!clientId || !clientSecret) {
            showToast('Client ID and Client Secret are required', 'error');
            return;
        }

        try {
            const response = await fetch('/admin/api/trakt/accounts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name || 'Trakt Account', clientId, clientSecret })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create account');
            }

            showToast('Trakt account created', 'success');
            hideAddTraktAccountForm();
            await loadTraktAccounts();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function deleteTraktAccount(accountId) {
        if (!confirm('Delete this Trakt account? Any linked profiles will be unlinked.')) return;

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}`, { method: 'DELETE' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to delete account');
            }
            showToast('Trakt account deleted', 'success');
            await loadTraktAccounts();
            await loadUserProfiles();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function connectTraktAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/auth/start`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to start auth');
            }

            const data = await response.json();
            traktAuthAccountId = accountId;

            // Show auth modal
            document.getElementById('traktAuthModal').style.display = 'flex';
            document.getElementById('traktUserCode').textContent = data.userCode;
            document.getElementById('traktAuthUrl').href = data.verificationUrl;
            document.getElementById('traktAuthUrl').textContent = data.verificationUrl;

            // Start polling
            const pollInterval = (data.interval || 5) * 1000;
            traktPollInterval = setInterval(() => pollTraktAuth(accountId, data.deviceCode), pollInterval);

            // Set timeout
            setTimeout(() => {
                if (traktPollInterval) {
                    clearInterval(traktPollInterval);
                    traktPollInterval = null;
                    cancelTraktAuth();
                    showToast('Authorization timed out', 'error');
                }
            }, (data.expiresIn || 600) * 1000);
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function pollTraktAuth(accountId, deviceCode) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/auth/check/${deviceCode}`);
            const data = await response.json();

            if (data.authenticated) {
                clearInterval(traktPollInterval);
                traktPollInterval = null;
                document.getElementById('traktAuthModal').style.display = 'none';
                showToast('Successfully connected to Trakt', 'success');
                await loadTraktAccounts();
                renderProfileTraktLinking();
            }
        } catch (err) {
            console.error('Poll error:', err);
        }
    }

    function cancelTraktAuth() {
        if (traktPollInterval) {
            clearInterval(traktPollInterval);
            traktPollInterval = null;
        }
        document.getElementById('traktAuthModal').style.display = 'none';
        traktAuthAccountId = null;
    }

    async function disconnectTraktAccount(accountId) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/disconnect`, { method: 'POST' });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to disconnect');
            }
            showToast('Disconnected from Trakt', 'success');
            await loadTraktAccounts();
            renderProfileTraktLinking();
        } catch (err) {
            showToast(err.message, 'error');
        }
    }

    async function toggleAccountScrobbling(accountId, enabled) {
        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/scrobbling`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled })
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to update scrobbling');
            }
            showToast(`Scrobbling ${enabled ? 'enabled' : 'disabled'}`, 'success');
        } catch (err) {
            showToast(err.message, 'error');
            // Reload to reset toggle state
            await loadTraktAccounts();
        }
    }

    async function updateProfileTraktLink(profileId, traktAccountId) {
        try {
            const method = traktAccountId ? 'PUT' : 'DELETE';
            const response = await fetch(`/admin/api/users/${profileId}/trakt`, {
                method,
                headers: { 'Content-Type': 'application/json' },
                body: traktAccountId ? JSON.stringify({ traktAccountId }) : undefined
            });
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to update profile');
            }
            showToast(traktAccountId ? 'Profile linked to Trakt account' : 'Profile unlinked from Trakt', 'success');
            await loadUserProfiles();
            await loadTraktAccounts();
        } catch (err) {
            showToast(err.message, 'error');
            await loadUserProfiles();
        }
    }

    function updateTraktHistorySection() {
        const historyNotConnected = document.getElementById('traktHistoryNotConnected');
        const historyConnected = document.getElementById('traktHistoryConnected');
        const accountSelect = document.getElementById('traktHistoryAccountSelect');

        const connectedAccounts = traktAccounts.filter(a => a.connected);

        if (connectedAccounts.length > 0) {
            if (historyNotConnected) historyNotConnected.style.display = 'none';
            if (historyConnected) historyConnected.style.display = 'block';

            // Populate account select for history import
            if (accountSelect) {
                accountSelect.innerHTML = connectedAccounts.map(acc =>
                    `<option value="${acc.id}">${escapeHtml(acc.name || acc.username || 'Unnamed')}</option>`
                ).join('');
            }
        } else {
            if (historyNotConnected) historyNotConnected.style.display = 'block';
            if (historyConnected) historyConnected.style.display = 'none';
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Legacy compatibility - redirect old function calls
    function loadTraktStatus() { loadTraktAccounts(); }
    function saveTraktCredentials() { showAddTraktAccountForm(); }

    // ========== Trakt History Import Functions ==========
    async function fetchTraktHistory() {
        const fetchBtn = document.getElementById('traktHistoryFetchBtn');
        const accountSelect = document.getElementById('traktHistoryAccountSelect');
        const accountId = accountSelect?.value;

        if (!accountId) {
            showToast('Please select a Trakt account', 'error');
            return;
        }

        fetchBtn.disabled = true;
        document.getElementById('traktHistoryLoading').style.display = 'block';
        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'none';

        try {
            const response = await fetch(`/admin/api/trakt/accounts/${accountId}/history?all=true`);
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to fetch history');
            }

            const data = await response.json();
            traktHistoryItems = data.items || [];

            // Select all by default
            traktHistorySelectedItems.clear();
            traktHistoryItems.forEach((item, idx) => traktHistorySelectedItems.add(idx));

            renderTraktHistoryTable();
            document.getElementById('traktHistoryLoading').style.display = 'none';
            document.getElementById('traktHistoryPreview').style.display = 'block';
            document.getElementById('traktHistoryImportBtnWrapper').style.display = 'block';
            updateTraktHistorySelectedCount();

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('traktHistoryLoading').style.display = 'none';
            document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        } finally {
            fetchBtn.disabled = false;
        }
    }

    function renderTraktHistoryTable() {
        const tbody = document.getElementById('traktHistoryTableBody');
        const countEl = document.getElementById('traktHistoryCount');

        countEl.textContent = `${traktHistoryItems.length} item${traktHistoryItems.length !== 1 ? 's' : ''}`;

        if (traktHistoryItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-muted); padding: 2rem;">Your Trakt history is empty</td></tr>';
            return;
        }

        tbody.innerHTML = traktHistoryItems.map((item, idx) => {
            const isSelected = traktHistorySelectedItems.has(idx);
            const watchedDate = new Date(item.watchedAt).toLocaleDateString();

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleTraktHistoryItem(${idx}, this.checked)">
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(item.title)}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td style="color: var(--text-muted);">${watchedDate}</td>
                </tr>
            `;
        }).join('');
    }

    function toggleTraktHistoryItem(idx, checked) {
        if (checked) {
            traktHistorySelectedItems.add(idx);
        } else {
            traktHistorySelectedItems.delete(idx);
        }
        updateTraktHistorySelectedCount();
        updateTraktHistoryRowStyles();
    }

    function traktHistorySelectAll(checked) {
        traktHistorySelectedItems.clear();
        if (checked) {
            traktHistoryItems.forEach((_, idx) => traktHistorySelectedItems.add(idx));
        }

        document.querySelectorAll('#traktHistoryTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('traktHistorySelectAllCheckbox').checked = checked;

        updateTraktHistorySelectedCount();
        updateTraktHistoryRowStyles();
    }

    function updateTraktHistorySelectedCount() {
        document.getElementById('traktHistorySelectedCount').textContent = traktHistorySelectedItems.size;
        document.getElementById('traktHistoryImportBtn').disabled = traktHistorySelectedItems.size === 0;

        const selectAllCb = document.getElementById('traktHistorySelectAllCheckbox');
        selectAllCb.checked = traktHistorySelectedItems.size === traktHistoryItems.length;
        selectAllCb.indeterminate = traktHistorySelectedItems.size > 0 && traktHistorySelectedItems.size < traktHistoryItems.length;
    }

    function updateTraktHistoryRowStyles() {
        document.querySelectorAll('#traktHistoryTableBody tr').forEach((row, idx) => {
            if (traktHistoryItems[idx]) {
                row.classList.toggle('disabled', !traktHistorySelectedItems.has(idx));
            }
        });
    }

    async function importTraktHistory() {
        if (traktHistorySelectedItems.size === 0) {
            showToast('Please select at least one item to import', 'error');
            return;
        }

        const profileId = document.getElementById('traktHistoryProfileSelect').value;
        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        const itemsToImport = Array.from(traktHistorySelectedItems).map(idx => traktHistoryItems[idx]);

        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryImporting').style.display = 'block';
        document.getElementById('traktHistoryImportProgress').textContent = `0 of ${itemsToImport.length}`;

        try {
            const response = await fetch('/admin/api/trakt/import/history', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: itemsToImport
                })
            });

            const result = await response.json();

            document.getElementById('traktHistoryImporting').style.display = 'none';
            document.getElementById('traktHistoryComplete').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('traktHistoryImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watch history`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('traktHistoryImporting').style.display = 'none';
            document.getElementById('traktHistoryPreview').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetTraktHistoryImport() {
        document.getElementById('traktHistoryComplete').style.display = 'none';
        document.getElementById('traktHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        traktHistoryItems = [];
        traktHistorySelectedItems.clear();
    }

    function resetTraktHistoryLoad() {
        document.getElementById('traktHistoryPreview').style.display = 'none';
        document.getElementById('traktHistoryImportBtnWrapper').style.display = 'none';
        document.getElementById('traktHistoryFetchBtnWrapper').style.display = 'block';
        traktHistoryItems = [];
        traktHistorySelectedItems.clear();
    }

    // ========== Plex Functions ==========
    async function loginWithPlex() {
        const loginBtn = document.getElementById('plexLoginBtn');
        loginBtn.disabled = true;
        loginBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px;"></div> Starting...';

        try {
            const response = await fetch('/admin/api/plex/pin', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create PIN');
            }

            const data = await response.json();
            const authWindow = window.open(data.authUrl, 'plex_auth', 'width=800,height=600');

            document.getElementById('plexNotConnected').style.display = 'none';
            document.getElementById('plexAuthWaiting').style.display = 'block';

            plexPollInterval = setInterval(async () => {
                try {
                    const checkResponse = await fetch(`/admin/api/plex/pin/${data.id}`);
                    const checkData = await checkResponse.json();

                    if (checkData.authenticated) {
                        clearInterval(plexPollInterval);
                        plexPollInterval = null;

                        if (authWindow && !authWindow.closed) {
                            authWindow.close();
                        }

                        // Reload Plex status from backend (token is saved automatically)
                        await loadPlexStatus();
                        document.getElementById('plexAuthWaiting').style.display = 'none';
                    }
                } catch (err) {
                    console.error('Poll error:', err);
                }
            }, 2000);

            setTimeout(() => {
                if (plexPollInterval) {
                    clearInterval(plexPollInterval);
                    plexPollInterval = null;
                    document.getElementById('plexAuthWaiting').style.display = 'none';
                    document.getElementById('plexNotConnected').style.display = 'block';
                    loginBtn.disabled = false;
                    loginBtn.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg> Login with Plex';
                    showToast('Authentication timed out', 'error');
                }
            }, 300000);

        } catch (err) {
            showToast(err.message, 'error');
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg> Login with Plex';
        }
    }

    function plexLogout() {
        disconnectPlex();
        plexWatchlistItems = [];
        plexSelectedItems.clear();

        // Reset watchlist import UI
        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexCompleteSection').style.display = 'none';
    }

    async function fetchPlexWatchlist() {
        const fetchBtn = document.getElementById('plexFetchBtn');
        fetchBtn.disabled = true;
        document.getElementById('plexLoadingSection').style.display = 'block';
        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'none';

        try {
            const response = await fetch('/admin/api/plex/watchlist');

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to fetch watchlist');
            }

            const data = await response.json();
            plexWatchlistItems = data.items || [];

            plexSelectedItems.clear();
            plexWatchlistItems.forEach(item => plexSelectedItems.add(item.ratingKey));

            renderPlexWatchlistTable();
            document.getElementById('plexLoadingSection').style.display = 'none';
            document.getElementById('plexPreviewSection').style.display = 'block';
            document.getElementById('plexImportBtnWrapper').style.display = 'block';
            updatePlexSelectedCount();

        } catch (err) {
            showToast(err.message, 'error');
            document.getElementById('plexLoadingSection').style.display = 'none';
            document.getElementById('plexFetchBtnWrapper').style.display = 'block';
        } finally {
            fetchBtn.disabled = false;
        }
    }

    function renderPlexWatchlistTable() {
        const tbody = document.getElementById('plexWatchlistTableBody');
        const countEl = document.getElementById('plexWatchlistCount');

        countEl.textContent = `${plexWatchlistItems.length} item${plexWatchlistItems.length !== 1 ? 's' : ''}`;

        if (plexWatchlistItems.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-muted); padding: 2rem;">Your Plex watchlist is empty</td></tr>';
            return;
        }

        tbody.innerHTML = plexWatchlistItems.map(item => {
            const isSelected = plexSelectedItems.has(item.ratingKey);
            const ids = item.externalIds || {};
            const idBadges = Object.entries(ids)
                .filter(([k, v]) => v && k !== 'plex')
                .map(([k, v]) => `<span class="id-badge">${k.toUpperCase()}</span>`)
                .join('');

            return `
                <tr class="${isSelected ? '' : 'disabled'}">
                    <td>
                        <input type="checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="togglePlexItem('${item.ratingKey}', this.checked)">
                    </td>
                    <td>
                        ${item.posterUrl
                            ? `<img src="${item.posterUrl}" class="poster-thumb" loading="lazy" onerror="this.style.display='none'">`
                            : '<div class="poster-thumb"></div>'}
                    </td>
                    <td style="font-weight: 500;">${escapeHtml(item.title)}</td>
                    <td style="color: var(--text-muted);">${item.year || '-'}</td>
                    <td><span class="type-badge ${item.type}">${item.type}</span></td>
                    <td><div class="id-badges">${idBadges || '<span class="id-badge">PLEX</span>'}</div></td>
                </tr>
            `;
        }).join('');
    }

    function togglePlexItem(ratingKey, checked) {
        if (checked) {
            plexSelectedItems.add(ratingKey);
        } else {
            plexSelectedItems.delete(ratingKey);
        }
        updatePlexSelectedCount();
        updatePlexRowStyles();
    }

    function plexSelectAll(checked) {
        plexSelectedItems.clear();
        if (checked) {
            plexWatchlistItems.forEach(item => plexSelectedItems.add(item.ratingKey));
        }

        document.querySelectorAll('#plexWatchlistTableBody input[type="checkbox"]').forEach(cb => {
            cb.checked = checked;
        });
        document.getElementById('plexSelectAllCheckbox').checked = checked;

        updatePlexSelectedCount();
        updatePlexRowStyles();
    }

    function updatePlexSelectedCount() {
        document.getElementById('plexSelectedCount').textContent = plexSelectedItems.size;
        document.getElementById('plexImportBtn').disabled = plexSelectedItems.size === 0;

        const selectAllCb = document.getElementById('plexSelectAllCheckbox');
        selectAllCb.checked = plexSelectedItems.size === plexWatchlistItems.length;
        selectAllCb.indeterminate = plexSelectedItems.size > 0 && plexSelectedItems.size < plexWatchlistItems.length;
    }

    function updatePlexRowStyles() {
        document.querySelectorAll('#plexWatchlistTableBody tr').forEach((row, index) => {
            if (plexWatchlistItems[index]) {
                const isSelected = plexSelectedItems.has(plexWatchlistItems[index].ratingKey);
                row.classList.toggle('disabled', !isSelected);
            }
        });
    }

    async function importPlexWatchlist() {
        if (plexSelectedItems.size === 0) {
            showToast('Please select at least one item to import', 'error');
            return;
        }

        const profileId = document.getElementById('plexProfileSelect').value;
        if (!profileId) {
            showToast('Please select a profile', 'error');
            return;
        }

        const itemsToImport = plexWatchlistItems.filter(item => plexSelectedItems.has(item.ratingKey));

        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexImportingSection').style.display = 'block';
        document.getElementById('plexImportProgress').textContent = `0 of ${itemsToImport.length}`;

        try {
            const response = await fetch('/admin/api/plex/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    profileId: profileId,
                    items: itemsToImport
                })
            });

            const result = await response.json();

            document.getElementById('plexImportingSection').style.display = 'none';
            document.getElementById('plexCompleteSection').style.display = 'block';

            let summary = `Successfully imported ${result.imported} item${result.imported !== 1 ? 's' : ''}.`;
            if (result.failed > 0) {
                summary += ` ${result.failed} item${result.failed !== 1 ? 's' : ''} failed.`;
            }
            document.getElementById('plexImportSummary').textContent = summary;

            if (result.success) {
                showToast(`Imported ${result.imported} items to watchlist`, 'success');
            } else {
                showToast(`Imported ${result.imported} items with ${result.failed} failures`, 'warning');
            }

        } catch (err) {
            document.getElementById('plexImportingSection').style.display = 'none';
            document.getElementById('plexPreviewSection').style.display = 'block';
            showToast('Import failed: ' + err.message, 'error');
        }
    }

    function resetPlexImport() {
        document.getElementById('plexCompleteSection').style.display = 'none';
        document.getElementById('plexImportBtnWrapper').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'block';
        plexWatchlistItems = [];
        plexSelectedItems.clear();
    }

    function resetPlexWatchlistLoad() {
        document.getElementById('plexPreviewSection').style.display = 'none';
        document.getElementById('plexImportBtnWrapper').style.display = 'none';
        document.getElementById('plexFetchBtnWrapper').style.display = 'block';
        plexWatchlistItems = [];
        plexSelectedItems.clear();
    }

    // ========== Utilities ==========
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>
{{end}}
